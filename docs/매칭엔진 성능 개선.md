매칭엔진을 구현하는 과정에서 초기에 선택한 방식은 DB 기반이었다. <br>
즉, 매수/매도 주문이 들어오면, DB에 저장하고, Spring Scheduling을 활용하여 일정 주기마다 매칭 작업을 수행하는 방식이었다. <br>
초기엔 구현 자체에 집중했기 때문에, 성능에 대한 고려는 하지 않았다. <br>
이제는 모두 구현이 완료되었기에, 성능 테스트를 통해 개선 방안을 모색하고자 한다.

# 성능 테스트 (DB 기반 매칭엔진)
실제 수치를 보기 위해 K6를 활용하여 요청을 발생시켰다. <br>
순수 성능만을 테스트하기 위해 인증, 인가, 기타 부가적인 기능들은 모두 제거한 상태에서 테스트를 진행했다. <br>
이후 Grafana를 활용하여 지연 시간을 모니터링했다. <br>

## 테스트 조건
테스트는 다음과 같은 조건으로 진행했다. <br>
- VU(Virtual User): 10명
- 테스트 시간: 30초
- 매수/매도 비율: 50:50
- 각 VU당 요청 간 간격: 0.1초

## 테스트 결과
<img width="679" height="248" alt="스크린샷 2025-09-06 오전 1 51 05" src="https://github.com/user-attachments/assets/e443b6f4-2ec1-46bf-922a-98a66016f9ee" />

테스트에서 중점적으로 확인한 항목은 *지연 시간(latency)* 이다. <br>
결과에서 알 수 있듯이, 지연 시간은 약 0.0236ms로 나타났다. <br>
사실 이 수치는 굉장히 빠른 수치이며, 당연하게도 테스트를 진행한 조건으로는 부하가 걸릴 수 없었다. <br>
실제 서비스 환경에 버금가는 트래픽을 발생시키기엔 컴퓨터 성능적 한계가 존재했기에, 테스트 조건을 소량 증가시켜 재테스트를 진행했다. <br>

## 재테스트 조건
- VU(Virtual User): 50명
- 테스트 시간: 30초
- 매수/매도 비율: 50:50
- 각 VU당 요청 간 간격: 0.1초

## 재테스트 결과
<img width="843" height="246" alt="스크린샷 2025-09-06 오전 1 37 59" src="https://github.com/user-attachments/assets/8fe7391a-7e0a-42f4-991b-f5e8b913fa8b" />

재테스트 결과, 평균 지연 시간은 약 0.025ms로 나타났다. <br>
이는 여전히 매우 빠른 수치지만, 실제 코인 거래소 환경에서는 수천~수만 명의 사용자가 동시에 주문을 넣는다. <br>
이때 DB 기반 매칭 방식은 다음과 같은 한계를 가진다.

- 주문 처리 시마다 DB에 접근해야 하므로 **디스크 I/O 지연**이 누적된다.
- 동시에 들어온 다수의 주문은 **트랜잭션 충돌** 및 **락 경합**을 유발한다.
  - 트랜잭션 충돌 : 여러 트랜잭션이 동일한 데이터를 동시에 수정하려고 할 때, 데이터 무결성을 위해 일부 트랜잭션이 실패하거나 재시도되는 상황을 말한다. 주로 낙관적 락 환경에서 발생하며, 충돌이 감지되면 트랜잭션을 다시 수행해야 한다.
  - 락 경합 : 데이터에 대해 비관적 락을 걸 경우, 다른 트랜잭션이 같은 데이터를 수정하려고 하면 대기하게 된다. 동시에 많은 트랜잭션이 몰리면 대기 시간이 누적되어 처리 속도가 느려지는 현상이 발생한다.
- 따라서 소규모 테스트에서는 빠르지만, 대규모 트래픽 상황에서는 DB I/O와 동시성 문제로 인해 확장성의 한계가 분명히 존재한다.

# 개선 방안 모색
이 문제를 해결하기 위해, 매칭 엔진을 **DB 기반 → In-Memory 기반**으로 전환하는 방안을 고려했다.
- In-Memory 기반 매칭 엔진은 모든 연산이 메모리에서 이루어지므로, **디스크 I/O 병목을 제거**할 수 있다.  
- Redis는 단일 스레드 이벤트 루프 기반으로 동작하기 때문에, 동시성 경쟁 상황에서도 트랜잭션 충돌이나 락 경합 문제를 최소화할 수 있다.

따라서 단기적으로는 현재 성능도 충분하지만,  
장기적으로는 **대규모 트래픽에 대비하기 위해 In-Memory 기반 전환이 필요하다**고 판단했다.

## Redis 기반 매칭 엔진 설계
새로운 매칭엔진은 Redis를 활용하여 설계했다. <br>
Redis를 사용한 이유에 대해선 추후에 자세히 다루도록 하겠다. <br>

## 구현
Redis 기반 매칭엔진은 다음과 같은 구조로 구현했다. <br>

1. **OrderBook을 Redis Hash 자료구조로 구현**
- 각 주문은 하나의 Key-Value로 저장
- Key : orderbook:{orderId}
- Value : OrderBook 객체를 JSON 직렬화한 값
```json
  {
  "id": 131,
  "userId": 1001,
  "coinId": 2001,
  "price": 50000,
  "remainingAmount": 2,
  "type": "BUY",
  "orderId": 131
  }
```

2. **가격 단위로 Order ID를 Set에 저장**
- 가격별 주문 ID를 Set으로 관리하여 매칭 시 빠르게 접근
- Set Key : orderbook:{type}:{price}
- Set values : {10000, 12345, ...}

3. **Type 별 가격 목록 Set 관리**
- 현재 매칭 가능한 가격 리스트를 Type 단위로 관리
- Set Key : prices:{type}
- Set values : {10000, 9990, ...}

4. **매칭 로직 구현**
   1. 매칭 가능한 가격 리스트 조회
   - BUY 가격 목록을 순회
   - 해당 가격과 동일한 SELL 주문이 존재하는지 확인
   2. 주문 가져오기
   - 가격별 Set에서 하나의 주문 ID를 가져옴
   3. 주문 상세 조회
   - ID를 통해 Hash에서 주문 상세 정보 조회(사용자 ID, 잔여 수량, 가격 등)
   4. 체결 수량 결정
   - 매수, 매도 잔여 수량을 비교 후 작은 수량으로 체결
   5. 잔여 수량 업데이트
   - 체결된 수량만큼 잔여 수량 차감
   - 잔여 수량이 0이 되면 해당 주문 삭제
   6. 주문 체결 이벤트 발행

# 성능 테스트 (Redis 기반 매칭엔진)
다시 K6를 활용하여 동일한 조건으로 테스트를 진행했다. <br>

## 테스트 1
- VU(Virtual User): 10명
- 테스트 시간: 30초
- 매수/매도 비율: 50:50
- 각 VU당 요청 간 간격: 0.1초

## 테스트 1 결과
<img width="646" height="246" alt="스크린샷 2025-09-16 오전 5 35 47" src="https://github.com/user-attachments/assets/b33b0871-2eaf-4f3c-8a3b-7e96dc62e16a" />

테스트 결과, 평균 지연 시간은 약 1.17ms로 나타났다. <br>
DB 기반 매칭엔진에 비해 매우 느린 수치이다. <br>
당연히 빠르다고 생각했지만, 결과는 반대였다. <br>


## 테스트 2
- VU(Virtual User): 50명
- 테스트 시간: 30초
- 매수/매도 비율: 50:50
- 각 VU당 요청 간 간격: 0.1초

## 테스트 2 결과
<img width="1134" height="279" alt="스크린샷 2025-09-17 오후 2 57 11" src="https://github.com/user-attachments/assets/636fbb22-0ddd-4f19-afcc-2779020031e4" />

마찬가지로 DB 기반 매칭엔진에 비해 매우 느린 수치가 나왔다. <br>
이유를 분석하고 개선 방향과 함께 따로 정리해 두었다.
https://velog.io/@devinsight/Redis는-과연-무조건-빠를까

# 결론
Redis 기반 매칭엔진의 지연시간이 더 길었던 이유를 찾고 개선했지만, 결국엔 DB 기반 매칭엔진에 비해선 느렸다. <br>
하지만 이는 적은 트래픽 상황에서의 결과이며, DB 병목이 생기는 대규모 트래픽 상황에서는 확실히 Redis 기반 매칭엔진이 더 유리할 것이다. <br>
